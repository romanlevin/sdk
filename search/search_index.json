{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Welcome to Trinsic \u00b6 Trinsic is a developer platform to exchange verifiable credentials. Verifiable Credentials transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly. Unlike a paper document or html form, when information from a verifiable credential is shared, it can be instantly proven to be authentic. They require no centralized authority or proprietary technology to use - verifiable credentials are built on interoperable standards designed to be open, privacy-preserving, and distributed like the internet itself. Hundreds of organizations of all sizes and industries use Trinsic\u2019s infrastructure and tools to instantly verify information about individuals with technology instead of paper. Available SDKs \u00b6 C# Xamarin (iOS, Android) .NET Core (MacOS, Windows, Linux) Web Assembly TypeScript/JS Node.js Browser Python Up Next \u00b6 Objective C (iOS) Java/Kotlin (Android) React Native Rust Go","title":"Overview"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#welcome-to-trinsic","text":"Trinsic is a developer platform to exchange verifiable credentials. Verifiable Credentials transform credentials, licenses, passes, and certificates into a W3C standard format that can be exchanged digitally and verified instantly. Unlike a paper document or html form, when information from a verifiable credential is shared, it can be instantly proven to be authentic. They require no centralized authority or proprietary technology to use - verifiable credentials are built on interoperable standards designed to be open, privacy-preserving, and distributed like the internet itself. Hundreds of organizations of all sizes and industries use Trinsic\u2019s infrastructure and tools to instantly verify information about individuals with technology instead of paper.","title":"Welcome to Trinsic"},{"location":"#available-sdks","text":"C# Xamarin (iOS, Android) .NET Core (MacOS, Windows, Linux) Web Assembly TypeScript/JS Node.js Browser Python","title":"Available SDKs"},{"location":"#up-next","text":"Objective C (iOS) Java/Kotlin (Android) React Native Rust Go","title":"Up Next"},{"location":"early-adopter/","text":"Introducing Trinsic Ecosystems \u00b6 For organizations ready to deploy verifiable credentials into a complex industry or use case, Trinsic has prepared tools to help you do so. To learn more about Trinsic Ecosystems, read our announcement about it: Announcing Trinsic Ecosystems","title":"Join Trinsic Ecosystems"},{"location":"early-adopter/#introducing-trinsic-ecosystems","text":"For organizations ready to deploy verifiable credentials into a complex industry or use case, Trinsic has prepared tools to help you do so. To learn more about Trinsic Ecosystems, read our announcement about it: Announcing Trinsic Ecosystems","title":"Introducing Trinsic Ecosystems"},{"location":"concepts/","text":"Concepts \u00b6 Trinsic is a set of tools and infrastructure that enables decentralized identity for individuals and organizations. There are many ways that decentralized identity can be used beyond just customer login. This enables digital identity verification anywhere. In person, online, even offline. Wallets \u00b6 Wallets can be thought of a little like an email inbox. Wallets exist to send, receive and store credentials. Wallets can be hosted by anyone. Each wallet can only be accessed by a set of keys stored on devices. Credentials \u00b6 Organizations and governments across the world have converged on a digital identity document standard called Verifiable Credentials. Trinsic's platform covers the full credential lifecycle. Our tools help you create, issue, verify, revoke, and store these credentials. These pieces are meant to be modular and interoperable. Verifiable Credentials are a way of representing documents online that make them interoperable and instantly verifiable. In its technical sense, a credential is a set of one or more cryptographically verifiable assertions about a subject made by an entity. Just like passports and drivers licenses today have interoperability components like their barcode, credentials have the same feature but are built into the internet itself, and can be used anywhere it is supported. Our tools let you choose to support the standard. By following the verifiable credential standard, your organization can issue digital documents that can be verified anywhere. For a technical deep dive, refer to the Verifiable Credentials Data Model Passes \u00b6 Passes are documents generated from one or more credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties. Underlying Tech \u00b6 Linked Data \u00b6 When we consider credentials getting exchanged online far and wide, a problem starts to occur - how does everyone know what every else means when they show a credential? To the rescue comes Linked Data, a format for representing structured data with self-contained descriptors of that data. \"Linked data is to spreadsheets and databases what the web of hypertext documents is to word processor files\" - W3C Wiki on Linked Data Decentralized Identifiers \u00b6 Taken from the Verifiable Credential Data Model , a decentralized identifier is \"a portable URL-based identifier, also known as a DID, associated with an entity. These identifiers are most often used in a verifiable credential and are associated with subjects such that a verifiable credential itself can be easily ported from one repository to another without the need to reissue the credential. An example of a DID is did:example:123456abcdef \" Zero Knowledge Proofs \u00b6 One of the most excited qualities of verifiable credentials are their ability to minimize the data shared about you when you prove who you are. The classic example is showing your driver's license in a bar. While a human bouncer may forget all the revealing information on your driver's license, a computerized bouncer that scans your driver's license never forgets any information. With zero knowledge proofs, you can choose specific information from your credentials to share with verifiers. These are enabled through a BBS+ Signature specification .","title":"Concepts"},{"location":"concepts/#concepts","text":"Trinsic is a set of tools and infrastructure that enables decentralized identity for individuals and organizations. There are many ways that decentralized identity can be used beyond just customer login. This enables digital identity verification anywhere. In person, online, even offline.","title":"Concepts"},{"location":"concepts/#wallets","text":"Wallets can be thought of a little like an email inbox. Wallets exist to send, receive and store credentials. Wallets can be hosted by anyone. Each wallet can only be accessed by a set of keys stored on devices.","title":"Wallets"},{"location":"concepts/#credentials","text":"Organizations and governments across the world have converged on a digital identity document standard called Verifiable Credentials. Trinsic's platform covers the full credential lifecycle. Our tools help you create, issue, verify, revoke, and store these credentials. These pieces are meant to be modular and interoperable. Verifiable Credentials are a way of representing documents online that make them interoperable and instantly verifiable. In its technical sense, a credential is a set of one or more cryptographically verifiable assertions about a subject made by an entity. Just like passports and drivers licenses today have interoperability components like their barcode, credentials have the same feature but are built into the internet itself, and can be used anywhere it is supported. Our tools let you choose to support the standard. By following the verifiable credential standard, your organization can issue digital documents that can be verified anywhere. For a technical deep dive, refer to the Verifiable Credentials Data Model","title":"Credentials"},{"location":"concepts/#passes","text":"Passes are documents generated from one or more credentials that contain only the information required to be verified. They can be generated in advance or in real-time. Passes minimize the information about you that is shared with third parties.","title":"Passes"},{"location":"concepts/#underlying-tech","text":"","title":"Underlying Tech"},{"location":"reference/services/provider-service/","text":"Provider Service \u00b6 This service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure. Onboarding \u00b6 Invite Participants \u00b6 Users can be onboarded as participants in the ecosystem by sending an invitation and a security code. This code can be sent directly through them using existing platforms or via email, SMS, etc. When users accept this invitation, they should do so using the service methods as described in creating wallet with provider invitation In Trinsic Ecosystems, participants can be Individuals or Organizations. This distinction is important, as providers have the ability to apply restrictions on what functionalities can be invoked by these participants. Additonally, Organizations have the ability to write their DID Document to a public ledger. Currently, the supported ledger is Sovrin, with ION and Element still in development. Trinsic CLI trinsic provider invite --organization --method-email admin@faber.edu trinsic provider invite --person --method-email alice@faber.edu TypeScript import { ProviderService, ParticipantType } from \"@trinsic/trinsic\"; const providerService = new ProviderService(); let inviteRequest = new InviteRequest(); inviteRequest.setParticipant(ParticipantType.PARTICIPANT_TYPE_ORGANIZATION); inviteRequest.setEmail(\"admin@faber.edu\"); const inviteResponse = await providerService.inviteParticipant(inviteRequest); console.log(inviteResponse.getInvitationId()); C# using Trinsic; var providerService = new ProviderService(); var inviteRequest = new InviteRequest { ParticipantType = ParticipantType.Organization, Email = \"admin@faber.edu\" } let inviteResponse = await providerService.InviteParticipant(inviteRequest); Console.WriteLine(inviteResponse.InvitationId); The invitationId in the response contains the security code that users must supply when creating their wallet. If using email method in onboarding, they will receive this code in their email.","title":"Provider Service"},{"location":"reference/services/provider-service/#provider-service","text":"This service helps ecosystem providers with data management and onboarding. This service requires a security profile with administrative authorization access. This can be obtained during the deployment of your ecosystem infrastructure.","title":"Provider Service"},{"location":"reference/services/provider-service/#onboarding","text":"","title":"Onboarding"},{"location":"reference/services/wallet-service/","text":"Wallet Service \u00b6 The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020 specficiation by W3C CCG. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production. Create Wallet \u00b6 Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider. Create wallet directly \u00b6 To create a wallet directly without invitation, use the following methods. These methods return secure profile data that should be stored in a safe place. The profile is used to authenticate the wallet service with the cloud provider. Read more details and recommendations in the Security Profiles page. Trinsic CLI trinsic wallet create --name <profile_name> TypeScript const profile = await walletService.createWallet(); C# var profile = await walletService.Create(); Create wallet with provider invitation \u00b6 If invited by a provider, you can supply the security code found in your invitation (via email, SMS, etc). Read more about inviting participants to your ecosystem as provider. Trinsic CLI trinsic wallet create --name <profile> --security-code <code> TypeScript const profile = await walletService.createWallet(\"<security code>\"); C# var profile = await walletService.Create(\"<security code>\"); Insert Record \u00b6 This method allows inserting any JSON data in the wallet. Trinsic CLI trinsic wallet insert-item --item <INPUT_JSON_FILE> TypeScript let itemId = await walletService.insertItem({ \"foo\": \"bar\" }); C# var item = new JObject { { \"foo\", \"bar\" } }; var itemId = await walletService.InsertItem(item); The output of this method will be a unique itemId that can be used as input where required. Search / Query \u00b6 Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This apporach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries. This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development. Basic Search \u00b6 The default query used in the commands below returns a full wallet result set. The query is SELECT * FROM c . Trinsic CLI trinsic wallet search TypeScript const items = await walletService.Search(); C# var items = await walletService.Search(); SQL Search \u00b6 To pass custom query to the search function, use the query parameter or the available overload. Trinsic CLI trinsic wallet search \\ --query \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\" TypeScript const query = \"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\"; const items = await walletService.search(query); C# var items = await walletService.Search(\"SELECT * FROM c WHERE c.type = 'VerifiableCredential'\"); Common SQL Queries \u00b6 Paging \u00b6 Paging uses the OFFSET clause that takes in a value indicating how many records should be skipped in the returned query. To specify the size of the result set (page size) use the LIMIT clause. SELECT * FROM c OFFSET 10 LIMIT 5 Sorting \u00b6 The optional ORDER BY clause specifies the sorting order for results returned by the query. To control sorting order, specify ASC or DESC at the end; if not specified ascending order is used by default. SELECT * FROM c ORDER BY c.credential.issued DESC Filtering \u00b6 The optional WHERE clause ( WHERE <filter_condition> ) specifies condition(s) that the source JSON items must satisfy for the query to include them in results. A JSON item must evaluate the specified conditions to true to be considered for the result. The index layer uses the WHERE clause to determine the smallest subset of source items that can be part of the result. SELECT * FROM c WHERE c.name = 'Trinsic' AND c.dateCreated >= \"2020-09-30T23:14:25.7251173Z\" Grouping \u00b6 The GROUP BY clause divides the query's results according to the values of one or more specified properties. Examples and detailed description on working with grouped results can be found here Additional Resources \u00b6 You can read the full documentation on working with SQL queries on the Azure Cosmos DB website . Issue Credential \u00b6 The wallet service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation. This endpoint requires that the user provide a valid JSON-LD document. Trinsic CLI trinsic issuer issue --document <INPUT_JSONLD_FILE> --out <OUTPUT_FILE> TypeScript let unsignedDocument = { \"@context\": \"https://w3id.org/security/v2\", \"id\": \"https://issuer.oidp.uscis.gov/credentials/83627465\" } let signedDocument = await walletService.issue(unsignedDocument); C# var unsignedDocument = new JObject { { \"@context\", \"https://w3id.org/security/v2\" }, { \"id\", \"https://issuer.oidp.uscis.gov/credentials/83627465\" } }; var signedDocument = await walletService.IssueCredential(unsignedDocument); The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document. Create Proof \u00b6 Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs . Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document. The endpoint to create a proof requires two inputs: document in the wallet that is signed with the correct signature JSONLD frame that describes the data to be disclosed Trinsic CLI trinsic issuer create-proof --document-id <STRING> --out <OUTPUT_FILE> --reveal-document <JSONLD_FRAME_FILE> TypeScript let frame = { \"@context\": \"https://www.w3.org/2018/credentials/v1\", \"type\": [ \"VerifiableCredential\" ], \"@explicit\": true, \"issuer\": {} } let itemId = \"<item document id>\"; let signedDocument = await walletService.createProof(itemId, frame); C# var frame = new JObject { { \"@context\", \"https://www.w3.org/2018/credentials/v1\" }, { \"@explicit\", true } { \"issuer\", new JObject() } }; var itemId = \"<item document id>\"; var signedDocument = await walletService.CreateProof(itemId, frame); Verify Proof \u00b6 This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme. Trinsic CLI trinsic issuer verify-proof --proof-document <JSONLD_FILE> TypeScript let isValid = await walletService.verifyProof(proofDocument); console.log(\"Verify result: \" + isValid); C# var isValid = await walletService.VerifyProof(proofDocument); Console.WriteLine($\"Verify result: {isValid}\"); Data Exchange \u00b6 Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods. DIDComm Messaging Wallet And Credential Interactions OpenID Connect Credential Provider During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK. Sending documents using Email as identifier \u00b6 To send a document to another user, they must have created a wallet and associated their email address with that wallet. Trinsic CLI trinsic wallet send --email <EMAIL_ADDRESS> --item <FILE> TypeScript await walletService.send(document, \"admin@example.com\"); C# await walletService.Send(document, \"admin@example.com\");","title":"Wallet Service"},{"location":"reference/services/wallet-service/#wallet-service","text":"The wallet service is the main interface for interacting with a cloud wallet. The service endpoints are designed to closely match the recommendations of the Universal Wallet 2020 specficiation by W3C CCG. The service exposes a gRPC interface and a set of data contracts as described in the specification. Our intention with this design is to bring it closer to interoperability as more implementations of this wallet appear in production.","title":"Wallet Service"},{"location":"reference/services/wallet-service/#create-wallet","text":"Wallets can be created directly by the user or through an invitation by the ecosystem provider. Depending on the ecosystem settings, direct wallet creation may not be enabled for your provider.","title":"Create Wallet"},{"location":"reference/services/wallet-service/#insert-record","text":"This method allows inserting any JSON data in the wallet. Trinsic CLI trinsic wallet insert-item --item <INPUT_JSON_FILE> TypeScript let itemId = await walletService.insertItem({ \"foo\": \"bar\" }); C# var item = new JObject { { \"foo\", \"bar\" } }; var itemId = await walletService.InsertItem(item); The output of this method will be a unique itemId that can be used as input where required.","title":"Insert Record"},{"location":"reference/services/wallet-service/#search-query","text":"Querying wallet data in our SDK is enabled through the use of familiar SQL syntax. All data is stored in JSON-LD format, so it can be easily searched. This apporach allows us to give developers full control over how data is retrieved. In addition to customizable sorting, paging and filtering, developers have the ability to construct projections, combine result sets, and even run user-defined functions over their queries. This endpoint will support querying using Verifiable Presentation Request Spec . This feature is still in development.","title":"Search / Query"},{"location":"reference/services/wallet-service/#issue-credential","text":"The wallet service supports signing data using BBS+ Signatures . The data is signed with a key unique to the owner's wallet. This key is also used as linked secret, when it comes to proof derivation. This endpoint requires that the user provide a valid JSON-LD document. Trinsic CLI trinsic issuer issue --document <INPUT_JSONLD_FILE> --out <OUTPUT_FILE> TypeScript let unsignedDocument = { \"@context\": \"https://w3id.org/security/v2\", \"id\": \"https://issuer.oidp.uscis.gov/credentials/83627465\" } let signedDocument = await walletService.issue(unsignedDocument); C# var unsignedDocument = new JObject { { \"@context\", \"https://w3id.org/security/v2\" }, { \"id\", \"https://issuer.oidp.uscis.gov/credentials/83627465\" } }; var signedDocument = await walletService.IssueCredential(unsignedDocument); The output of this method will be a signed JSON document using BBS+ Signature Suite 2020. This document is not automatically stored in the wallet when issued. You need to call the insert record separately if you'd like to store a copy of this document.","title":"Issue Credential"},{"location":"reference/services/wallet-service/#create-proof","text":"Wallets allow data to be shared between parties in a secure manner, using a technique called Zero Knowledge Proofs . Trinsic Ecosystems uses the BBS+ Signature Proof scheme to allow data to be selectively disclosed to the requesting party. This allows users to share only the requested subset of data, instead the entire document. The endpoint to create a proof requires two inputs: document in the wallet that is signed with the correct signature JSONLD frame that describes the data to be disclosed Trinsic CLI trinsic issuer create-proof --document-id <STRING> --out <OUTPUT_FILE> --reveal-document <JSONLD_FRAME_FILE> TypeScript let frame = { \"@context\": \"https://www.w3.org/2018/credentials/v1\", \"type\": [ \"VerifiableCredential\" ], \"@explicit\": true, \"issuer\": {} } let itemId = \"<item document id>\"; let signedDocument = await walletService.createProof(itemId, frame); C# var frame = new JObject { { \"@context\", \"https://www.w3.org/2018/credentials/v1\" }, { \"@explicit\", true } { \"issuer\", new JObject() } }; var itemId = \"<item document id>\"; var signedDocument = await walletService.CreateProof(itemId, frame);","title":"Create Proof"},{"location":"reference/services/wallet-service/#verify-proof","text":"This endpoint verifies if the submitted data contains a valid proof. The data to be verified must contain a Linked Data Proof with BBS+ signature scheme. Trinsic CLI trinsic issuer verify-proof --proof-document <JSONLD_FILE> TypeScript let isValid = await walletService.verifyProof(proofDocument); console.log(\"Verify result: \" + isValid); C# var isValid = await walletService.VerifyProof(proofDocument); Console.WriteLine($\"Verify result: {isValid}\");","title":"Verify Proof"},{"location":"reference/services/wallet-service/#data-exchange","text":"Exchanging data securely is one of the fundamental functions of digital identity systems. There are many specifications with varying maturity that aim to provide interoperable and secure way of exchanging authentic data. We are commited to providing support for these methods. DIDComm Messaging Wallet And Credential Interactions OpenID Connect Credential Provider During this beta period, we are only supporting exchanging data between users by using their email addresses. The messages are routed securely to the destination wallet without leaving the secure network of the ecosystem backend. Our goal is to provide basic ability to share data without affecting the user experience. As interoperable exchange methods become available, we will add this functionality in the SDK.","title":"Data Exchange"},{"location":"reference/setup/","text":"Setup \u00b6 Installation \u00b6 If you are ready to begin integrating the SDK into an existing project, make sure you have an SDK installed. We currently provide a CLI, TypeScript, and C# SDKs for local development. If you're here to just go through the walkthrough, check out our Gitpod cloud environment for easy installation (You'll have to create a free account with gitpod). Trinsic CLI TypeScript C# Authorization \u00b6 Trinsic Ecosystems uses authenticated access for accessing personal data. This is implemented using Authorization Capabilities for Linked Data (ZCAP-LD for short). Zcaps provide a secure way for linked data systems to grant and express authority utilizing the object capability model. Our wallet capabilities are represented as linked data objects which are signed with Linked Data Proofs. LD Proofs represent the core technology of the way we share and exchange authentic data with others. Profile Data Format \u00b6 Security Profiles are represented as a protobuf message that contains details about the connecting device to the remote cloud wallet. These are sensitive details that contain private key data, and must always be stored in a secure storage. The details of this data contract are expressed with this proto message. message WalletProfile { google.protobuf.Struct did_document = 1; string wallet_id = 2; string invoker = 3; string capability = 4; bytes invoker_jwk = 5; } did_document contains the DID Document generated by the device that will be used to access the remote wallet. Each device/profile will have a unique DID Document. The DID method used in this document is did:key . wallet_id represents the remote wallet identifier that this profile has been granted access. invoker represents the specific key in the DID Document that was granted capability authorization. capability represents the unique identifier of the z-cap that the invoker is allowed to access. invoker_jwk represents the key of the invoker in JWK format. This key is already present in the DID Document, we simply store it here in JWK format for convenience. This profile is always stored in its binary form using the protobuf native serialization. A profile is created by using the Create Wallet functionality in the SDK. Configuration \u00b6 Trinsic SDK contains minimal configuration. This configuration is stored differently, depending on what package is used. Configuration with CLI \u00b6 The CLI stores it's configuration in the user's home directory, typically in ~/.trinsic/ . This directory contains the main configuration file config.toml and all the profile data. Show Configuration \u00b6 To print the current configuration file in the terminal use: trinsic config --show Typical configuration file may look like this: [server] address = \"http://localhost:5000/\" [profile] default = \"my_profile\" Update Configuration Entry \u00b6 To change the configuration values, use the config subcommand with the attribute and it's value. trinsic config <attribute_name> <attribute_value> The following attributes are currently supported: server-address Updates the default server address the CLI communicates trinsic config --server-address https://example.com/ profile-default Updates the default profile used with the CLI trinsic config --profile-default alice Configuration with SDK \u00b6 When using the SDK in your code, you can pass parameters to the default service constructors and use the provided methods to set different active profiles. TypeScript import { WalletService } from '@trinsic/trinsic'; // Set the server address const service = new WalletService(\"https://example.com\"); // Create new profile or import an existing one const myProfile = await service.createWallet(); // Set the profile to be used with authorization pipeline service.setProfile(myProfile); C# using Trinsic; // Set the server address var service = new WalletService(\"https://example.com\"); // Create new profile or import an existing one var myProfile = await service.CreateWallet(); // Set the profile to be used with authorization pipeline service.SetProfile(myProfile);","title":"Setup"},{"location":"reference/setup/#setup","text":"","title":"Setup"},{"location":"reference/setup/#installation","text":"If you are ready to begin integrating the SDK into an existing project, make sure you have an SDK installed. We currently provide a CLI, TypeScript, and C# SDKs for local development. If you're here to just go through the walkthrough, check out our Gitpod cloud environment for easy installation (You'll have to create a free account with gitpod). Trinsic CLI TypeScript C#","title":"Installation"},{"location":"reference/setup/#authorization","text":"Trinsic Ecosystems uses authenticated access for accessing personal data. This is implemented using Authorization Capabilities for Linked Data (ZCAP-LD for short). Zcaps provide a secure way for linked data systems to grant and express authority utilizing the object capability model. Our wallet capabilities are represented as linked data objects which are signed with Linked Data Proofs. LD Proofs represent the core technology of the way we share and exchange authentic data with others.","title":"Authorization"},{"location":"reference/setup/#configuration","text":"Trinsic SDK contains minimal configuration. This configuration is stored differently, depending on what package is used.","title":"Configuration"},{"location":"reference/setup/configuration/","text":"Configuration \u00b6 Trinsic SDK contains minimal configuration. This configuration is stored differently, depending on what package is used. Configuration with CLI \u00b6 The CLI stores it's configuration in the user's home directory, typically in ~/.trinsic/ . This directory contains the main configuration file config.toml and all the profile data. Show Configuration \u00b6 To print the current configuration file in the terminal use: trinsic config --show Typical configuration file may look like this: [server] address = \"http://localhost:5000/\" [profile] default = \"my_profile\" Update Configuration Entry \u00b6 To change the configuration values, use the config subcommand with the attribute and it's value. trinsic config <attribute_name> <attribute_value> The following attributes are currently supported: server-address Updates the default server address the CLI communicates trinsic config --server-address https://example.com/ profile-default Updates the default profile used with the CLI trinsic config --profile-default alice Configuration with SDK \u00b6 When using the SDK in your code, you can pass parameters to the default service constructors and use the provided methods to set different active profiles. TypeScript import { WalletService } from '@trinsic/trinsic'; // Set the server address const service = new WalletService(\"https://example.com\"); // Create new profile or import an existing one const myProfile = await service.createWallet(); // Set the profile to be used with authorization pipeline service.setProfile(myProfile); C# using Trinsic; // Set the server address var service = new WalletService(\"https://example.com\"); // Create new profile or import an existing one var myProfile = await service.CreateWallet(); // Set the profile to be used with authorization pipeline service.SetProfile(myProfile);","title":"Configuration"},{"location":"reference/setup/configuration/#configuration","text":"Trinsic SDK contains minimal configuration. This configuration is stored differently, depending on what package is used.","title":"Configuration"},{"location":"reference/setup/profiles/","text":"Security Profiles / Authorization \u00b6 Trinsic Ecosystems uses authenticated access for accessing personal data. This is implemented using Authorization Capabilities for Linked Data (ZCAP-LD for short). Zcaps provide a secure way for linked data systems to grant and express authority utilizing the object capability model. Our wallet capabilities are represented as linked data objects which are signed with Linked Data Proofs. LD Proofs represent the core technology of the way we share and exchange authentic data with others. Profile Data Format \u00b6 Security Profiles are represented as a protobuf message that contains details about the connecting device to the remote cloud wallet. These are sensitive details that contain private key data, and must always be stored in a secure storage. The details of this data contract are expressed with this proto message. message WalletProfile { google.protobuf.Struct did_document = 1; string wallet_id = 2; string invoker = 3; string capability = 4; bytes invoker_jwk = 5; } did_document contains the DID Document generated by the device that will be used to access the remote wallet. Each device/profile will have a unique DID Document. The DID method used in this document is did:key . wallet_id represents the remote wallet identifier that this profile has been granted access. invoker represents the specific key in the DID Document that was granted capability authorization. capability represents the unique identifier of the z-cap that the invoker is allowed to access. invoker_jwk represents the key of the invoker in JWK format. This key is already present in the DID Document, we simply store it here in JWK format for convenience. This profile is always stored in its binary form using the protobuf native serialization. A profile is created by using the Create Wallet functionality in the SDK.","title":"Security Profiles / Authorization"},{"location":"reference/setup/profiles/#security-profiles-authorization","text":"Trinsic Ecosystems uses authenticated access for accessing personal data. This is implemented using Authorization Capabilities for Linked Data (ZCAP-LD for short). Zcaps provide a secure way for linked data systems to grant and express authority utilizing the object capability model. Our wallet capabilities are represented as linked data objects which are signed with Linked Data Proofs. LD Proofs represent the core technology of the way we share and exchange authentic data with others.","title":"Security Profiles / Authorization"},{"location":"reference/setup/profiles/#profile-data-format","text":"Security Profiles are represented as a protobuf message that contains details about the connecting device to the remote cloud wallet. These are sensitive details that contain private key data, and must always be stored in a secure storage. The details of this data contract are expressed with this proto message. message WalletProfile { google.protobuf.Struct did_document = 1; string wallet_id = 2; string invoker = 3; string capability = 4; bytes invoker_jwk = 5; } did_document contains the DID Document generated by the device that will be used to access the remote wallet. Each device/profile will have a unique DID Document. The DID method used in this document is did:key . wallet_id represents the remote wallet identifier that this profile has been granted access. invoker represents the specific key in the DID Document that was granted capability authorization. capability represents the unique identifier of the z-cap that the invoker is allowed to access. invoker_jwk represents the key of the invoker in JWK format. This key is already present in the DID Document, we simply store it here in JWK format for convenience. This profile is always stored in its binary form using the protobuf native serialization. A profile is created by using the Create Wallet functionality in the SDK.","title":"Profile Data Format"},{"location":"reference/setup/installation/install-cli/","text":"The CLI can be installed directly using the Cargo tool. This requires the Rustup toolchain installed on your system. Once installed, run this command in terminal: cargo install --git https://github.com/trinsic-id/sdk.git --branch main To verify that the CLI has been installed successfully, try running: trinsic --help","title":"Install cli"},{"location":"reference/setup/installation/install-net/","text":"Install the packages directly from Nuget.org Package Manager PM> Install-Package Trinsic .NET CLI > dotnet add package Trinsic PackageReference <PackageReference Include=\"Trinsic\" />","title":"Install net"},{"location":"reference/setup/installation/install-node/","text":"Install the package for Node or Browser from npmjs.com Install npm i @trinsic/trinsic","title":"Install node"},{"location":"walkthrough/vaccination-browser/","text":"Vaccination Use Case for Browsers \u00b6 In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information. Ecosystem setup \u00b6 Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service. Technical requirements \u00b6 You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need node and npm installed on your machine and a code editor of your choice. Create new project \u00b6 Let's create a new console app that we will use to add our sample code mkdir VaccinationSample && cd VaccinationSample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic-web npm i --save-dev http-server webpack webpack-cli Configure Webpack \u00b6 After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file const path = require('path'); module.exports = { mode: 'development', entry: './src/index.js', output: { path: path.resolve(__dirname, './src'), filename: 'bundle.js', } }; Set up Website \u00b6 Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create. <!DOCTYPE html> <html lang=\"en\"> <head> <title>Vaccination Sample</title> <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /> <meta name=\"description\" content=\"\" /> </head> <body> <h1>Vaccination Sample</h1> <div id=\"wallet\"></div> </body> <script src=\"../bundle.js\"></script> </html> Your file structure should look like this VaccinationSample src index.html index.js package.json webpack.config.js Configure services \u00b6 Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your index.js file add the following line replacing the placeholder with your URL: const { WalletService } = require('@trinsic/trinsic-web') const walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\"); Setup wallet profiles \u00b6 Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. let allison = await walletService.createWallet(); let clinic = await walletService.createWallet(); let airline = await walletService.createWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. const fs = require('fs'); const { Struct } = require('google-protobuf/google/protobuf/struct_pb'); // Serialize profile by exporting the binary protobuf form localStorage.setItem(\"allison.bin\", allison.serializeBinary()); // Create profile from existing data let allison = WalletProfile.deserializeBinary(localStorage.getItem(\"allison.bin\")); Loading Profiles In order to load a profile from a saved file you'll need to install google-protobuf with npm i google-protobuf in order to use the Struct class and convert the DID Document from JavaScript to the protobuf form. Read more about security profiles and authentication. Certificate issuance \u00b6 Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This ceritificate is digitially signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we load the JSON structure directly. // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.setProfile(clinic); // Read the JSON credential data let credentialJson = { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } }; // Sign the credential using BBS+ signature scheme let credential = await walletService.issueCredential(JSON.parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment. Store certificate in personal wallet \u00b6 Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.setProfile(allison); // Insert the signed credential let itemId = await walletService.insertItem(credential); Proof of vaccination \u00b6 Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison let proofRequestJson = { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } // Set the active profile to 'allison' walletService.setProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential let credentialProof = await walletService.createProof(itemId, JSON.parse(proofRequestJson)); Verification \u00b6 Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.setProfile(airline); // Check for valid signature let valid = await walletService.verifyProof(credentialProof); document.getElementById(\"wallet\").innerHTML = valid Build \u00b6 To build the bundle.js file run webpack build Run \u00b6 To serve the website and run the sample run npx http-server src Complete sample code \u00b6 This sample is available in our GitHub repo.","title":"Web"},{"location":"walkthrough/vaccination-browser/#vaccination-use-case-for-browsers","text":"In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information.","title":"Vaccination Use Case for Browsers"},{"location":"walkthrough/vaccination-browser/#ecosystem-setup","text":"Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Ecosystem setup"},{"location":"walkthrough/vaccination-browser/#technical-requirements","text":"You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need node and npm installed on your machine and a code editor of your choice.","title":"Technical requirements"},{"location":"walkthrough/vaccination-browser/#create-new-project","text":"Let's create a new console app that we will use to add our sample code mkdir VaccinationSample && cd VaccinationSample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic-web npm i --save-dev http-server webpack webpack-cli","title":"Create new project"},{"location":"walkthrough/vaccination-browser/#configure-webpack","text":"After installing the dependencies you'll need a configuration file for webpack. Create a file called webpack.config.js at the root of your project and then copy and paste this into that file const path = require('path'); module.exports = { mode: 'development', entry: './src/index.js', output: { path: path.resolve(__dirname, './src'), filename: 'bundle.js', } };","title":"Configure Webpack"},{"location":"walkthrough/vaccination-browser/#set-up-website","text":"Create a simple html page with a script tag referencing the webpack bundle that will be built after completing the sample code. Note that you will not have the bundle.js file yet because it will be generated from the index.js file you create. <!DOCTYPE html> <html lang=\"en\"> <head> <title>Vaccination Sample</title> <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" /> <meta name=\"description\" content=\"\" /> </head> <body> <h1>Vaccination Sample</h1> <div id=\"wallet\"></div> </body> <script src=\"../bundle.js\"></script> </html> Your file structure should look like this VaccinationSample src index.html index.js package.json webpack.config.js","title":"Set up Website"},{"location":"walkthrough/vaccination-browser/#configure-services","text":"Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your index.js file add the following line replacing the placeholder with your URL: const { WalletService } = require('@trinsic/trinsic-web') const walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\");","title":"Configure services"},{"location":"walkthrough/vaccination-browser/#setup-wallet-profiles","text":"Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. let allison = await walletService.createWallet(); let clinic = await walletService.createWallet(); let airline = await walletService.createWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. const fs = require('fs'); const { Struct } = require('google-protobuf/google/protobuf/struct_pb'); // Serialize profile by exporting the binary protobuf form localStorage.setItem(\"allison.bin\", allison.serializeBinary()); // Create profile from existing data let allison = WalletProfile.deserializeBinary(localStorage.getItem(\"allison.bin\")); Loading Profiles In order to load a profile from a saved file you'll need to install google-protobuf with npm i google-protobuf in order to use the Struct class and convert the DID Document from JavaScript to the protobuf form. Read more about security profiles and authentication.","title":"Setup wallet profiles"},{"location":"walkthrough/vaccination-browser/#certificate-issuance","text":"Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This ceritificate is digitially signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we load the JSON structure directly. // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.setProfile(clinic); // Read the JSON credential data let credentialJson = { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } }; // Sign the credential using BBS+ signature scheme let credential = await walletService.issueCredential(JSON.parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment.","title":"Certificate issuance"},{"location":"walkthrough/vaccination-browser/#store-certificate-in-personal-wallet","text":"Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.setProfile(allison); // Insert the signed credential let itemId = await walletService.insertItem(credential);","title":"Store certificate in personal wallet"},{"location":"walkthrough/vaccination-browser/#proof-of-vaccination","text":"Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison let proofRequestJson = { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } // Set the active profile to 'allison' walletService.setProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential let credentialProof = await walletService.createProof(itemId, JSON.parse(proofRequestJson));","title":"Proof of vaccination"},{"location":"walkthrough/vaccination-browser/#verification","text":"Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.setProfile(airline); // Check for valid signature let valid = await walletService.verifyProof(credentialProof); document.getElementById(\"wallet\").innerHTML = valid","title":"Verification"},{"location":"walkthrough/vaccination-browser/#build","text":"To build the bundle.js file run webpack build","title":"Build"},{"location":"walkthrough/vaccination-browser/#run","text":"To serve the website and run the sample run npx http-server src","title":"Run"},{"location":"walkthrough/vaccination-browser/#complete-sample-code","text":"This sample is available in our GitHub repo.","title":"Complete sample code"},{"location":"walkthrough/vaccination-cli/","text":"Vaccination Use Case for CLI \u00b6 It can be challenging to understand how verifiable credentials work until you see some examples. This walkthrough will show how a vaccination card might be issued, held, and proven using verifiable credentials with the Trinsic CLI. It assumes no prior knowledge to decentralized identity. In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information. Ecosystem setup \u00b6 Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service. Use case overview \u00b6 In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders. Install Trinsic CLI \u00b6 If you're here to just go through the walkthrough, check out our Gitpod cloud environment for easy installation (You'll have to create a free account with gitpod). Once installed, configure the CLI's server address to your Ecosystem: Trinsic CLI trinsic config --server-address https://example.com Noted Reference: Configuration with CLI Meet Allison \u00b6 Allison's town just received the go ahead to vaccinate everyone. We'll walk through a scenario where Allison gets her vaccination card and then generates a pass with it to board an airline, all using her devices. Create Wallets \u00b6 We'll start by creating a wallet for each participant in this credential exchange. Wallets can be created by anyone, for anyone. In this scenario, we have three wallets. Allison will be the credential holder, the Airline will be the verifier, and the vaccination clinic will be the issuer. These wallets have been created by you, your role is an ecosystem provider. Your role is to help deploy a credential exchange ecosystem. Trinsic CLI trinsic wallet create --description \"Allison's Wallet\" --name allison && \\ trinsic wallet create --description \"Airline's wallet\" --name airline && \\ trinsic wallet create --description \"Vaccination Clinic\" --name clinic Note Reference: Create Wallet Issue a Credential \u00b6 Each credential is a JSON-LD document that is signed with a special digital signature to makes each piece of data in the credential separately verifiable. This is a called bbs+ signature scheme. The credential is signed, but not sent. For now, sending the credential should be done through existing communication methods. Because this sample is on the same file system, our communicate method is simply moving it to allison's directory :) Trinsic CLI trinsic --profile clinic issuer issue --document vaccination-certificate-unsigned.jsonld --out ./clinic/vaccination-certificate-signed.jsonld mv ./vaccination-certificate-signed.jsonld allison Info Reference: Issue a Credential Store Credential in Wallet \u00b6 Once Allison receives the credential, she can store it within her wallet. She can use any device that she's authorized to use with her wallet. Trinsic CLI trinsic --profile allison wallet insert-item --item ./allison/vaccination-certificate-signed.jsonld Note down the response item_id printed to the console for the next step. Info Reference: Insert Record Create Proof \u00b6 Now let's create a proof for Allison. She may choose to generate this proof before going to the airport, or might generate it right as she boards. Replace the <item_id> in the generate proof command below with the output from the insert_item above. Trinsic CLI trinsic --profile allison issuer create-proof --document-id \"<item-id>\" --out ./vaccination-certificate-partial-proof.jsonld --reveal-document ./vaccination-certificate-frame.jsonld more vaccination-certificate-partial-proof.jsonld mv vaccination-certificate-partial-proof.json ../airline Take a look at the proof. Notice how only the attributes included in the frame are included with the proof. Allison sends this proof to the airline for them to verify. Info Reference: Create Proof Verify Proof \u00b6 Once the airline receives the proof, they can now verify it to ensure its authenticity. Because Allison sent a proof of her vaccination credential and not the credential itself, the airline only receives its required information. Trinsic CLI trinsic --profile airline issuer verify-proof --proof-document ./airline/vaccination-certificate-partial-proof.jsonld Watch for the output of true to know that the credential successfully passed all of the verification processes. Info Reference: Verify Proof","title":"CLI"},{"location":"walkthrough/vaccination-cli/#vaccination-use-case-for-cli","text":"It can be challenging to understand how verifiable credentials work until you see some examples. This walkthrough will show how a vaccination card might be issued, held, and proven using verifiable credentials with the Trinsic CLI. It assumes no prior knowledge to decentralized identity. In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information.","title":"Vaccination Use Case for CLI"},{"location":"walkthrough/vaccination-cli/#ecosystem-setup","text":"Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Ecosystem setup"},{"location":"walkthrough/vaccination-cli/#use-case-overview","text":"In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders.","title":"Use case overview"},{"location":"walkthrough/vaccination-cli/#install-trinsic-cli","text":"If you're here to just go through the walkthrough, check out our Gitpod cloud environment for easy installation (You'll have to create a free account with gitpod). Once installed, configure the CLI's server address to your Ecosystem: Trinsic CLI trinsic config --server-address https://example.com Noted Reference: Configuration with CLI","title":"Install Trinsic CLI"},{"location":"walkthrough/vaccination-cli/#meet-allison","text":"Allison's town just received the go ahead to vaccinate everyone. We'll walk through a scenario where Allison gets her vaccination card and then generates a pass with it to board an airline, all using her devices.","title":"Meet Allison"},{"location":"walkthrough/vaccination-cli/#create-wallets","text":"We'll start by creating a wallet for each participant in this credential exchange. Wallets can be created by anyone, for anyone. In this scenario, we have three wallets. Allison will be the credential holder, the Airline will be the verifier, and the vaccination clinic will be the issuer. These wallets have been created by you, your role is an ecosystem provider. Your role is to help deploy a credential exchange ecosystem. Trinsic CLI trinsic wallet create --description \"Allison's Wallet\" --name allison && \\ trinsic wallet create --description \"Airline's wallet\" --name airline && \\ trinsic wallet create --description \"Vaccination Clinic\" --name clinic Note Reference: Create Wallet","title":"Create Wallets"},{"location":"walkthrough/vaccination-cli/#issue-a-credential","text":"Each credential is a JSON-LD document that is signed with a special digital signature to makes each piece of data in the credential separately verifiable. This is a called bbs+ signature scheme. The credential is signed, but not sent. For now, sending the credential should be done through existing communication methods. Because this sample is on the same file system, our communicate method is simply moving it to allison's directory :) Trinsic CLI trinsic --profile clinic issuer issue --document vaccination-certificate-unsigned.jsonld --out ./clinic/vaccination-certificate-signed.jsonld mv ./vaccination-certificate-signed.jsonld allison Info Reference: Issue a Credential","title":"Issue a Credential"},{"location":"walkthrough/vaccination-cli/#store-credential-in-wallet","text":"Once Allison receives the credential, she can store it within her wallet. She can use any device that she's authorized to use with her wallet. Trinsic CLI trinsic --profile allison wallet insert-item --item ./allison/vaccination-certificate-signed.jsonld Note down the response item_id printed to the console for the next step. Info Reference: Insert Record","title":"Store Credential in Wallet"},{"location":"walkthrough/vaccination-cli/#create-proof","text":"Now let's create a proof for Allison. She may choose to generate this proof before going to the airport, or might generate it right as she boards. Replace the <item_id> in the generate proof command below with the output from the insert_item above. Trinsic CLI trinsic --profile allison issuer create-proof --document-id \"<item-id>\" --out ./vaccination-certificate-partial-proof.jsonld --reveal-document ./vaccination-certificate-frame.jsonld more vaccination-certificate-partial-proof.jsonld mv vaccination-certificate-partial-proof.json ../airline Take a look at the proof. Notice how only the attributes included in the frame are included with the proof. Allison sends this proof to the airline for them to verify. Info Reference: Create Proof","title":"Create Proof"},{"location":"walkthrough/vaccination-cli/#verify-proof","text":"Once the airline receives the proof, they can now verify it to ensure its authenticity. Because Allison sent a proof of her vaccination credential and not the credential itself, the airline only receives its required information. Trinsic CLI trinsic --profile airline issuer verify-proof --proof-document ./airline/vaccination-certificate-partial-proof.jsonld Watch for the output of true to know that the credential successfully passed all of the verification processes. Info Reference: Verify Proof","title":"Verify Proof"},{"location":"walkthrough/vaccination-net/","text":"Vaccination Use Case for .NET Core \u00b6 In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information. Ecosystem setup \u00b6 Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service. Use case overview \u00b6 In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders. Technical requirements \u00b6 You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need .NET Core installed. We will use the dotnet CLI and the editor of your choice. Supported runtimes Xamarin targets for iOS and Android are fully supported using the same package dependencies. Support for Blazor in Web Assembly will be available in a future release. Create new project \u00b6 Let's create a new .NET console app that we will use to add our sample code dotnet new console -n VaccinationSample && cd VaccinationSample Add the required dependencies dotnet add package Trinsic --prerelease dotnet add package Okapi.Net --prerelease The package Okapi.Net is already a dependency of Trinsic package, but we must add explicitly to bring in static library dependencies. This will not be required in future version and only package Trinsic can be used. Configure services \u00b6 Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your Program.cs file add the following line replacing the placeholder with your URL: using Trinsic; var walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\"); Setup wallet profiles \u00b6 Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. var allison = await walletService.CreateWallet(); var clinic = await walletService.CreateWallet(); var airline = await walletService.CreateWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. using Google.Protobuf; using System.IO; // Serialize profile by exporting the binary protobuf form File.WriteAllBytes(\"allison.bin\", allison.ToByteString().ToByteArray()); // Create profile from existing data var allison = WalletProfile.Parser.ParseFrom(File.ReadAllBytes(\"allison.bin\")); Read more about security profiles and authentication. Certificate issuance \u00b6 Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } } Let's set the active profile to the clinic, and call the issuance endpoint // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.SetProfile(clinic); // Read the JSON credential data var credentialJson = File.ReadAllText(\"./vaccination-certificate-unsigned.jsonld\"); // Sign the credential using BBS+ signature scheme var credential = await walletService.IssueCredential(document: JObject.Parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment. Store certificate in personal wallet \u00b6 Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.SetProfile(allison); // Insert the signed credential var itemId = await walletService.InsertItem(credential); Proof of vaccination \u00b6 Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison var proofRequestJson = File.ReadAllText(\"./vaccination-certificate-frame.jsonld\"); // Set the active profile to 'allison' walletService.SetProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await walletService.CreateProof(itemId, JObject.Parse(proofRequestJson)); Verification \u00b6 Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.SetProfile(airline); // Check for valid signature var valid = await walletService.VerifyProof(credentialProof); Complete sample code \u00b6 This sample is available in our GitHub repo. You can also simply run the code using Replit and inspect the results. Run example in Replit","title":"C#"},{"location":"walkthrough/vaccination-net/#vaccination-use-case-for-net-core","text":"In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information.","title":"Vaccination Use Case for .NET Core"},{"location":"walkthrough/vaccination-net/#ecosystem-setup","text":"Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Ecosystem setup"},{"location":"walkthrough/vaccination-net/#use-case-overview","text":"In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders.","title":"Use case overview"},{"location":"walkthrough/vaccination-net/#technical-requirements","text":"You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need .NET Core installed. We will use the dotnet CLI and the editor of your choice. Supported runtimes Xamarin targets for iOS and Android are fully supported using the same package dependencies. Support for Blazor in Web Assembly will be available in a future release.","title":"Technical requirements"},{"location":"walkthrough/vaccination-net/#create-new-project","text":"Let's create a new .NET console app that we will use to add our sample code dotnet new console -n VaccinationSample && cd VaccinationSample Add the required dependencies dotnet add package Trinsic --prerelease dotnet add package Okapi.Net --prerelease The package Okapi.Net is already a dependency of Trinsic package, but we must add explicitly to bring in static library dependencies. This will not be required in future version and only package Trinsic can be used.","title":"Create new project"},{"location":"walkthrough/vaccination-net/#configure-services","text":"Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your Program.cs file add the following line replacing the placeholder with your URL: using Trinsic; var walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\");","title":"Configure services"},{"location":"walkthrough/vaccination-net/#setup-wallet-profiles","text":"Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. var allison = await walletService.CreateWallet(); var clinic = await walletService.CreateWallet(); var airline = await walletService.CreateWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. using Google.Protobuf; using System.IO; // Serialize profile by exporting the binary protobuf form File.WriteAllBytes(\"allison.bin\", allison.ToByteString().ToByteArray()); // Create profile from existing data var allison = WalletProfile.Parser.ParseFrom(File.ReadAllBytes(\"allison.bin\")); Read more about security profiles and authentication.","title":"Setup wallet profiles"},{"location":"walkthrough/vaccination-net/#certificate-issuance","text":"Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } } Let's set the active profile to the clinic, and call the issuance endpoint // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.SetProfile(clinic); // Read the JSON credential data var credentialJson = File.ReadAllText(\"./vaccination-certificate-unsigned.jsonld\"); // Sign the credential using BBS+ signature scheme var credential = await walletService.IssueCredential(document: JObject.Parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment.","title":"Certificate issuance"},{"location":"walkthrough/vaccination-net/#store-certificate-in-personal-wallet","text":"Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.SetProfile(allison); // Insert the signed credential var itemId = await walletService.InsertItem(credential);","title":"Store certificate in personal wallet"},{"location":"walkthrough/vaccination-net/#proof-of-vaccination","text":"Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison var proofRequestJson = File.ReadAllText(\"./vaccination-certificate-frame.jsonld\"); // Set the active profile to 'allison' walletService.SetProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential var credentialProof = await walletService.CreateProof(itemId, JObject.Parse(proofRequestJson));","title":"Proof of vaccination"},{"location":"walkthrough/vaccination-net/#verification","text":"Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.SetProfile(airline); // Check for valid signature var valid = await walletService.VerifyProof(credentialProof);","title":"Verification"},{"location":"walkthrough/vaccination-net/#complete-sample-code","text":"This sample is available in our GitHub repo. You can also simply run the code using Replit and inspect the results. Run example in Replit","title":"Complete sample code"},{"location":"walkthrough/vaccination-node/","text":"Vaccination Use Case for Node.js \u00b6 In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information. Ecosystem setup \u00b6 Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service. Use case overview \u00b6 In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders. Technical requirements \u00b6 You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need node and npm installed on your machine and a code editor of your choice. Create new project \u00b6 Let's create a new console app that we will use to add our sample code mkdir VaccinationSample && cd VaccinationSample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic Configure services \u00b6 Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your index.js file add the following line replacing the placeholder with your URL: const { WalletService } = require('@trinsic/trinsic') const walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\"); Setup wallet profiles \u00b6 Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. let allison = await walletService.createWallet(); let clinic = await walletService.createWallet(); let airline = await walletService.createWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. const fs = require('fs'); const { Struct } = require('google-protobuf/google/protobuf/struct_pb'); // Serialize profile by exporting the binary protobuf form fs.writeFileSync(\"allison.bin\", allison.serializeBinary()); // Create profile from existing data let profile = fs.readFileSync(\"allison.bin\"); let allison = WalletProfile.deserializeBinary(profile); Loading Profiles In order to load a profile from a saved file you'll need to install google-protobuf with npm i google-protobuf in order to use the Struct class and convert the DID Document from JavaScript to the protobuf form. Read more about security profiles and authentication. Certificate issuance \u00b6 Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } } Let's set the active profile to the clinic, and call the issuance endpoint // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.setProfile(clinic); // Read the JSON credential data let credentialJson = fs.readFileSync(\"./vaccination-certificate-unsigned.jsonld\"); // Sign the credential using BBS+ signature scheme let credential = await walletService.issueCredential(JSON.parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment. Store certificate in personal wallet \u00b6 Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.setProfile(allison); // Insert the signed credential let itemId = await walletService.insertItem(credential); Proof of vaccination \u00b6 Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison let proofRequestJson = fs.readFileSync(\"./vaccination-certificate-frame.jsonld\"); // Set the active profile to 'allison' walletService.setProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential let credentialProof = await walletService.createProof(itemId, JSON.parse(proofRequestJson)); Verification \u00b6 Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.setProfile(airline); // Check for valid signature let valid = await walletService.verifyProof(credentialProof); Complete sample code \u00b6 This sample is available in our GitHub repo.","title":"Node"},{"location":"walkthrough/vaccination-node/#vaccination-use-case-for-nodejs","text":"In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information.","title":"Vaccination Use Case for Node.js"},{"location":"walkthrough/vaccination-node/#ecosystem-setup","text":"Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Ecosystem setup"},{"location":"walkthrough/vaccination-node/#use-case-overview","text":"In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders.","title":"Use case overview"},{"location":"walkthrough/vaccination-node/#technical-requirements","text":"You can run this example on your local machine, or you can use our Gitpod setup to bootstrap a full development environment. If running locally, you only need node and npm installed on your machine and a code editor of your choice.","title":"Technical requirements"},{"location":"walkthrough/vaccination-node/#create-new-project","text":"Let's create a new console app that we will use to add our sample code mkdir VaccinationSample && cd VaccinationSample && npm init You can select all the defaults for the node project. Add the required dependencies npm i @trinsic/trinsic","title":"Create new project"},{"location":"walkthrough/vaccination-node/#configure-services","text":"Create a reference to the wallet service that points to your ecosystem service. You should have received this URL with your ecosystem setup. In your index.js file add the following line replacing the placeholder with your URL: const { WalletService } = require('@trinsic/trinsic') const walletService = new WalletService(\"<ECOSYSTEM SERVICE URL>\");","title":"Configure services"},{"location":"walkthrough/vaccination-node/#setup-wallet-profiles","text":"Let's create three different profiles, each pointing to a separate wallet. Since we are using a single console app for this demo, we will simply set the active profile before each interaction to designate which actor is currently taking action. To create a new wallet profile, we use the Create Wallet feature. let allison = await walletService.createWallet(); let clinic = await walletService.createWallet(); let airline = await walletService.createWallet(); If you would like to save the profile for future use, you can simply export the serialized profile to a local storage. Please note that the profiles contain sensitive key data, so they should be stored in a secure enclave. const fs = require('fs'); const { Struct } = require('google-protobuf/google/protobuf/struct_pb'); // Serialize profile by exporting the binary protobuf form fs.writeFileSync(\"allison.bin\", allison.serializeBinary()); // Create profile from existing data let profile = fs.readFileSync(\"allison.bin\"); let allison = WalletProfile.deserializeBinary(profile); Loading Profiles In order to load a profile from a saved file you'll need to install google-protobuf with npm i google-protobuf in order to use the Struct class and convert the DID Document from JavaScript to the protobuf form. Read more about security profiles and authentication.","title":"Setup wallet profiles"},{"location":"walkthrough/vaccination-node/#certificate-issuance","text":"Upon receiving her vaccine, Allison also receives a digital certificate from the clinic. This certificate is digitally signed by the clinic, acting as an issuer. The certificate is in a JSON form, and for this example, we will use the following JSON. Add this file to your project named vaccination-certificate-unsigned.jsonld . vaccination-certificate-unsigned.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"id\": \"urn:uvci:af5vshde843jf831j128fj\", \"type\": [ \"VaccinationCertificate\", \"VerifiableCredential\" ], \"description\": \"COVID-19 Vaccination Certificate\", \"name\": \"COVID-19 Vaccination Certificate\", \"expirationDate\": \"2029-12-03T12:19:52Z\", \"issuanceDate\": \"2019-12-03T12:19:52Z\", \"issuer\": \"did:key:zUC724vuGvHpnCGFG1qqpXb81SiBLu3KLSqVzenwEZNPoY35i2Bscb8DLaVwHvRFs6F2NkNNXRcPWvqnPDUd9ukdjLkjZd3u9zzL4wDZDUpkPAatLDGLEYVo8kkAzuAKJQMr7N2\", \"credentialSubject\": { \"id\": \"urn:uuid:c53e70f8-ce9a-4576-8744-e5f85c20a743\", \"type\": \"VaccinationEvent\", \"batchNumber\": \"1183738569\", \"countryOfVaccination\": \"US\" } } Let's set the active profile to the clinic, and call the issuance endpoint // Set active profile to 'clinic' so we can issue credential signed // with the clinic's signing keys walletService.setProfile(clinic); // Read the JSON credential data let credentialJson = fs.readFileSync(\"./vaccination-certificate-unsigned.jsonld\"); // Sign the credential using BBS+ signature scheme let credential = await walletService.issueCredential(JSON.parse(credentialJson)); At this point, the clinic can send the signed credential to Allison using any available methods. These methods can include any message exchange protocol, or a custom transport. In this case, we'll assume that the credential was delivered to Allison in an offline environment.","title":"Certificate issuance"},{"location":"walkthrough/vaccination-node/#store-certificate-in-personal-wallet","text":"Allison can store this credential in her cloud wallet, simply by calling the Insert Item function. // Set active profile to 'allison' so we can manage her cloud wallet walletService.setProfile(allison); // Insert the signed credential let itemId = await walletService.insertItem(credential);","title":"Store certificate in personal wallet"},{"location":"walkthrough/vaccination-node/#proof-of-vaccination","text":"Before boarding an airplane, Allison must show a proof of vaccination. The request for this proof also comes in a form of JSON, in this case a JSON-LD frame. This request can be communicated using any exchange protocol. Again, we'll assume this was done offline. Let's save this request in a file named vaccination-certificate-frame.jsonld vaccination-certificate-frame.jsonld { \"@context\": [ \"https://www.w3.org/2018/credentials/v1\", \"https://w3id.org/vaccination/v1\", \"https://w3id.org/security/bbs/v1\" ], \"type\": [ \"VerifiableCredential\", \"VaccinationCertificate\" ], \"@explicit\": true, \"issuer\": {}, \"credentialSubject\": { \"@explicit\": true, \"@type\": \"VaccinationEvent\", \"batchNumber\": {}, \"countryOfVaccination\": {} } } This request asks Allison to provide proof of valid vaccination certificate, including the issuer , batchNumber and countryOfVaccination fields. Allison can use the Create Proof functions to build a proof that will share only the requested fields. // We'll read the request frame from a file and communicate this with Allison let proofRequestJson = fs.readFileSync(\"./vaccination-certificate-frame.jsonld\"); // Set the active profile to 'allison' walletService.setProfile(allison); // Build a proof for the given request and the `itemId` we previously received // which points to the stored credential let credentialProof = await walletService.createProof(itemId, JSON.parse(proofRequestJson));","title":"Proof of vaccination"},{"location":"walkthrough/vaccination-node/#verification","text":"Allison shares the proof of credential she created with the airline. The airline can now use Verify Proof functions to check the validity of the proof. // Set active profile to 'airline' walletService.setProfile(airline); // Check for valid signature let valid = await walletService.verifyProof(credentialProof);","title":"Verification"},{"location":"walkthrough/vaccination-node/#complete-sample-code","text":"This sample is available in our GitHub repo.","title":"Complete sample code"},{"location":"walkthrough/snippets/intro-infrastructure/","text":"In this walkthrough we will showcase a practical example of how participants in an ecosystem use verifiable data to exchange trusted bits of information. Ecosystem setup \u00b6 Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Intro infrastructure"},{"location":"walkthrough/snippets/intro-infrastructure/#ecosystem-setup","text":"Before we begin, please ensure that you have a running ecosystems infrastructure. If you haven't yet, join our early adopter program to have your own dedicated infrastructure configured. Once your infrastructure is up, you will receive an endpoint to connect to your cloud service.","title":"Ecosystem setup"},{"location":"walkthrough/snippets/intro-use-case/","text":"Use case overview \u00b6 In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders.","title":"Intro use case"},{"location":"walkthrough/snippets/intro-use-case/#use-case-overview","text":"In this walkthrough we'll explore a scenario where Allison gets her vaccination certificate. She then uses this certificate to board an airline that requires proof of vaccination. Each participant in this scenario is part of the same ecosystem, though this is not a functional requirement. journey section Issuance Obtain cert.: 3: Allison, Clinic Store in wallet: 3: Allison section Verification Request cert.: 3: Allison, Airline Share: 3: Allison Verify: 5: Airline If you haven't learned about verifiable credentials already, first read Verifiable Credential Basics . In most credential exchange scenarios there are three primary roles - Issuer, Holder, and Verifier. Issuer : Responsible for issuing signed credentials that attest information about a credential subject Holder : Stores issued credentials from an issuer. Most often this is the credential subject. Also generates passes to share with verifiers. Verifier : Verifies passes presented from holders.","title":"Use case overview"}]}